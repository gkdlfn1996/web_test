{"ast":null,"code":"import \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.math.sign.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.timers.js\";\n// Composables\nimport { useDisplay } from \"./display.js\";\nimport { useResizeObserver } from \"./resizeObserver.js\"; // Utilities\nimport { computed, nextTick, onScopeDispose, ref, shallowRef, watch, watchEffect } from 'vue';\nimport { clamp, debounce, getPropertyFromItem, IN_BROWSER, propsFactory } from \"../util/index.js\"; // Types\nvar UP = -1;\nvar DOWN = 1;\n\n/** Determines how large each batch of items should be */\nvar BUFFER_PX = 100;\nexport var makeVirtualProps = propsFactory({\n  itemHeight: {\n    type: [Number, String],\n    \"default\": null\n  },\n  itemKey: {\n    type: [String, Array, Function],\n    \"default\": null\n  },\n  height: [Number, String]\n}, 'virtual');\nexport function useVirtual(props, items) {\n  var display = useDisplay();\n  var itemHeight = shallowRef(0);\n  watchEffect(function () {\n    itemHeight.value = parseFloat(props.itemHeight || 0);\n  });\n  var first = shallowRef(0);\n  var last = shallowRef(Math.ceil(\n  // Assume 16px items filling the entire screen height if\n  // not provided. This is probably incorrect but it minimises\n  // the chance of ending up with empty space at the bottom.\n  // The default value is set here to avoid poisoning getSize()\n  (parseInt(props.height) || display.height.value) / (itemHeight.value || 16)) || 1);\n  var paddingTop = shallowRef(0);\n  var paddingBottom = shallowRef(0);\n\n  /** The scrollable element */\n  var containerRef = ref();\n  /** An element marking the top of the scrollable area,\n   * used to add an offset if there's padding or other elements above the virtual list */\n  var markerRef = ref();\n  /** markerRef's offsetTop, lazily evaluated */\n  var markerOffset = 0;\n  var _useResizeObserver = useResizeObserver(),\n    resizeRef = _useResizeObserver.resizeRef,\n    contentRect = _useResizeObserver.contentRect;\n  watchEffect(function () {\n    resizeRef.value = containerRef.value;\n  });\n  var viewportHeight = computed(function () {\n    var _contentRect$value;\n    return containerRef.value === document.documentElement ? display.height.value : ((_contentRect$value = contentRect.value) === null || _contentRect$value === void 0 ? void 0 : _contentRect$value.height) || parseInt(props.height) || 0;\n  });\n  /** All static elements have been rendered and we have an assumed item height */\n  var hasInitialRender = computed(function () {\n    return !!(containerRef.value && markerRef.value && viewportHeight.value && itemHeight.value);\n  });\n  var sizes = Array.from({\n    length: items.value.length\n  });\n  var offsets = Array.from({\n    length: items.value.length\n  });\n  var updateTime = shallowRef(0);\n  var targetScrollIndex = -1;\n  function getSize(index) {\n    return sizes[index] || itemHeight.value;\n  }\n  var updateOffsets = debounce(function () {\n    var start = performance.now();\n    offsets[0] = 0;\n    var length = items.value.length;\n    for (var i = 1; i <= length - 1; i++) {\n      offsets[i] = (offsets[i - 1] || 0) + getSize(i - 1);\n    }\n    updateTime.value = Math.max(updateTime.value, performance.now() - start);\n  }, updateTime);\n  var unwatch = watch(hasInitialRender, function (v) {\n    if (!v) return;\n    // First render is complete, update offsets and visible\n    // items in case our assumed item height was incorrect\n\n    unwatch();\n    markerOffset = markerRef.value.offsetTop;\n    updateOffsets.immediate();\n    calculateVisibleItems();\n    if (!~targetScrollIndex) return;\n    nextTick(function () {\n      IN_BROWSER && window.requestAnimationFrame(function () {\n        scrollToIndex(targetScrollIndex);\n        targetScrollIndex = -1;\n      });\n    });\n  });\n  onScopeDispose(function () {\n    updateOffsets.clear();\n  });\n  function handleItemResize(index, height) {\n    var prevHeight = sizes[index];\n    var prevMinHeight = itemHeight.value;\n    itemHeight.value = prevMinHeight ? Math.min(itemHeight.value, height) : height;\n    if (prevHeight !== height || prevMinHeight !== itemHeight.value) {\n      sizes[index] = height;\n      updateOffsets();\n    }\n  }\n  function calculateOffset(index) {\n    index = clamp(index, 0, items.value.length - 1);\n    return offsets[index] || 0;\n  }\n  function calculateIndex(scrollTop) {\n    return binaryClosest(offsets, scrollTop);\n  }\n  var lastScrollTop = 0;\n  var scrollVelocity = 0;\n  var lastScrollTime = 0;\n  watch(viewportHeight, function (val, oldVal) {\n    if (oldVal) {\n      calculateVisibleItems();\n      if (val < oldVal) {\n        requestAnimationFrame(function () {\n          scrollVelocity = 0;\n          calculateVisibleItems();\n        });\n      }\n    }\n  });\n  var scrollTimeout = -1;\n  function handleScroll() {\n    if (!containerRef.value || !markerRef.value) return;\n    var scrollTop = containerRef.value.scrollTop;\n    var scrollTime = performance.now();\n    var scrollDeltaT = scrollTime - lastScrollTime;\n    if (scrollDeltaT > 500) {\n      scrollVelocity = Math.sign(scrollTop - lastScrollTop);\n\n      // Not super important, only update at the\n      // start of a scroll sequence to avoid reflows\n      markerOffset = markerRef.value.offsetTop;\n    } else {\n      scrollVelocity = scrollTop - lastScrollTop;\n    }\n    lastScrollTop = scrollTop;\n    lastScrollTime = scrollTime;\n    window.clearTimeout(scrollTimeout);\n    scrollTimeout = window.setTimeout(handleScrollend, 500);\n    calculateVisibleItems();\n  }\n  function handleScrollend() {\n    if (!containerRef.value || !markerRef.value) return;\n    scrollVelocity = 0;\n    lastScrollTime = 0;\n    window.clearTimeout(scrollTimeout);\n    calculateVisibleItems();\n  }\n  var raf = -1;\n  function calculateVisibleItems() {\n    cancelAnimationFrame(raf);\n    raf = requestAnimationFrame(_calculateVisibleItems);\n  }\n  function _calculateVisibleItems() {\n    if (!containerRef.value || !viewportHeight.value || !itemHeight.value) return;\n    var scrollTop = lastScrollTop - markerOffset;\n    var direction = Math.sign(scrollVelocity);\n    var startPx = Math.max(0, scrollTop - BUFFER_PX);\n    var start = clamp(calculateIndex(startPx), 0, items.value.length);\n    var endPx = scrollTop + viewportHeight.value + BUFFER_PX;\n    var end = clamp(calculateIndex(endPx) + 1, start + 1, items.value.length);\n    if (\n    // Only update the side we're scrolling towards,\n    // the other side will be updated incidentally\n    (direction !== UP || start < first.value) && (direction !== DOWN || end > last.value)) {\n      var topOverflow = calculateOffset(first.value) - calculateOffset(start);\n      var bottomOverflow = calculateOffset(end) - calculateOffset(last.value);\n      var bufferOverflow = Math.max(topOverflow, bottomOverflow);\n      if (bufferOverflow > BUFFER_PX) {\n        first.value = start;\n        last.value = end;\n      } else {\n        // Only update the side that's reached its limit if there's still buffer left\n        if (start <= 0) first.value = start;\n        if (end >= items.value.length) last.value = end;\n      }\n    }\n    paddingTop.value = calculateOffset(first.value);\n    paddingBottom.value = calculateOffset(items.value.length) - calculateOffset(last.value);\n  }\n  function scrollToIndex(index) {\n    var offset = calculateOffset(index);\n    if (!containerRef.value || index && !offset) {\n      targetScrollIndex = index;\n    } else {\n      containerRef.value.scrollTop = offset;\n    }\n  }\n  var computedItems = computed(function () {\n    return items.value.slice(first.value, last.value).map(function (item, index) {\n      var _index = index + first.value;\n      return {\n        raw: item,\n        index: _index,\n        key: getPropertyFromItem(item, props.itemKey, _index)\n      };\n    });\n  });\n  watch(items, function () {\n    sizes = Array.from({\n      length: items.value.length\n    });\n    offsets = Array.from({\n      length: items.value.length\n    });\n    updateOffsets.immediate();\n    calculateVisibleItems();\n  }, {\n    deep: 1\n  });\n  return {\n    calculateVisibleItems: calculateVisibleItems,\n    containerRef: containerRef,\n    markerRef: markerRef,\n    computedItems: computedItems,\n    paddingTop: paddingTop,\n    paddingBottom: paddingBottom,\n    scrollToIndex: scrollToIndex,\n    handleScroll: handleScroll,\n    handleScrollend: handleScrollend,\n    handleItemResize: handleItemResize\n  };\n}\n\n// https://gist.github.com/robertleeplummerjr/1cc657191d34ecd0a324\nfunction binaryClosest(arr, val) {\n  var high = arr.length - 1;\n  var low = 0;\n  var mid = 0;\n  var item = null;\n  var target = -1;\n  if (arr[high] < val) {\n    return high;\n  }\n  while (low <= high) {\n    mid = low + high >> 1;\n    item = arr[mid];\n    if (item > val) {\n      high = mid - 1;\n    } else if (item < val) {\n      target = mid;\n      low = mid + 1;\n    } else if (item === val) {\n      return mid;\n    } else {\n      return low;\n    }\n  }\n  return target;\n}","map":{"version":3,"names":["useDisplay","useResizeObserver","computed","nextTick","onScopeDispose","ref","shallowRef","watch","watchEffect","clamp","debounce","getPropertyFromItem","IN_BROWSER","propsFactory","UP","DOWN","BUFFER_PX","makeVirtualProps","itemHeight","type","Number","String","itemKey","Array","Function","height","useVirtual","props","items","display","value","parseFloat","first","last","Math","ceil","parseInt","paddingTop","paddingBottom","containerRef","markerRef","markerOffset","_useResizeObserver","resizeRef","contentRect","viewportHeight","_contentRect$value","document","documentElement","hasInitialRender","sizes","from","length","offsets","updateTime","targetScrollIndex","getSize","index","updateOffsets","start","performance","now","i","max","unwatch","v","offsetTop","immediate","calculateVisibleItems","window","requestAnimationFrame","scrollToIndex","clear","handleItemResize","prevHeight","prevMinHeight","min","calculateOffset","calculateIndex","scrollTop","binaryClosest","lastScrollTop","scrollVelocity","lastScrollTime","val","oldVal","scrollTimeout","handleScroll","scrollTime","scrollDeltaT","sign","clearTimeout","setTimeout","handleScrollend","raf","cancelAnimationFrame","_calculateVisibleItems","direction","startPx","endPx","end","topOverflow","bottomOverflow","bufferOverflow","offset","computedItems","slice","map","item","_index","raw","key","deep","arr","high","low","mid","target"],"sources":["../../src/composables/virtual.ts"],"sourcesContent":["// Composables\nimport { useDisplay } from '@/composables/display'\nimport { useResizeObserver } from '@/composables/resizeObserver'\n\n// Utilities\nimport { computed, nextTick, onScopeDispose, ref, shallowRef, watch, watchEffect } from 'vue'\nimport { clamp, debounce, getPropertyFromItem, IN_BROWSER, propsFactory } from '@/util'\n\n// Types\nimport type { PropType, Ref } from 'vue'\nimport type { SelectItemKey } from '@/util'\n\nconst UP = -1\nconst DOWN = 1\n\n/** Determines how large each batch of items should be */\nconst BUFFER_PX = 100\n\ntype VirtualProps = {\n  itemHeight: number | string | null | undefined\n  itemKey: SelectItemKey\n  height: number | string | undefined\n}\n\nexport const makeVirtualProps = propsFactory({\n  itemHeight: {\n    type: [Number, String],\n    default: null,\n  },\n  itemKey: {\n    type: [String, Array, Function] as PropType<SelectItemKey>,\n    default: null,\n  },\n  height: [Number, String],\n}, 'virtual')\n\nexport function useVirtual <T> (props: VirtualProps, items: Ref<readonly T[]>) {\n  const display = useDisplay()\n\n  const itemHeight = shallowRef(0)\n  watchEffect(() => {\n    itemHeight.value = parseFloat(props.itemHeight || 0)\n  })\n\n  const first = shallowRef(0)\n  const last = shallowRef(Math.ceil(\n    // Assume 16px items filling the entire screen height if\n    // not provided. This is probably incorrect but it minimises\n    // the chance of ending up with empty space at the bottom.\n    // The default value is set here to avoid poisoning getSize()\n    (parseInt(props.height!) || display.height.value) / (itemHeight.value || 16)\n  ) || 1)\n  const paddingTop = shallowRef(0)\n  const paddingBottom = shallowRef(0)\n\n  /** The scrollable element */\n  const containerRef = ref<HTMLElement>()\n  /** An element marking the top of the scrollable area,\n   * used to add an offset if there's padding or other elements above the virtual list */\n  const markerRef = ref<HTMLElement>()\n  /** markerRef's offsetTop, lazily evaluated */\n  let markerOffset = 0\n\n  const { resizeRef, contentRect } = useResizeObserver()\n  watchEffect(() => {\n    resizeRef.value = containerRef.value\n  })\n  const viewportHeight = computed(() => {\n    return containerRef.value === document.documentElement\n      ? display.height.value\n      : contentRect.value?.height || parseInt(props.height!) || 0\n  })\n  /** All static elements have been rendered and we have an assumed item height */\n  const hasInitialRender = computed(() => {\n    return !!(containerRef.value && markerRef.value && viewportHeight.value && itemHeight.value)\n  })\n\n  let sizes = Array.from<number | null>({ length: items.value.length })\n  let offsets = Array.from<number>({ length: items.value.length })\n  const updateTime = shallowRef(0)\n  let targetScrollIndex = -1\n\n  function getSize (index: number) {\n    return sizes[index] || itemHeight.value\n  }\n\n  const updateOffsets = debounce(() => {\n    const start = performance.now()\n    offsets[0] = 0\n    const length = items.value.length\n    for (let i = 1; i <= length - 1; i++) {\n      offsets[i] = (offsets[i - 1] || 0) + getSize(i - 1)\n    }\n    updateTime.value = Math.max(updateTime.value, performance.now() - start)\n  }, updateTime)\n\n  const unwatch = watch(hasInitialRender, v => {\n    if (!v) return\n    // First render is complete, update offsets and visible\n    // items in case our assumed item height was incorrect\n\n    unwatch()\n    markerOffset = markerRef.value!.offsetTop\n    updateOffsets.immediate()\n    calculateVisibleItems()\n\n    if (!~targetScrollIndex) return\n\n    nextTick(() => {\n      IN_BROWSER && window.requestAnimationFrame(() => {\n        scrollToIndex(targetScrollIndex)\n        targetScrollIndex = -1\n      })\n    })\n  })\n\n  onScopeDispose(() => {\n    updateOffsets.clear()\n  })\n\n  function handleItemResize (index: number, height: number) {\n    const prevHeight = sizes[index]\n    const prevMinHeight = itemHeight.value\n\n    itemHeight.value = prevMinHeight ? Math.min(itemHeight.value, height) : height\n\n    if (prevHeight !== height || prevMinHeight !== itemHeight.value) {\n      sizes[index] = height\n      updateOffsets()\n    }\n  }\n\n  function calculateOffset (index: number) {\n    index = clamp(index, 0, items.value.length - 1)\n    return offsets[index] || 0\n  }\n\n  function calculateIndex (scrollTop: number) {\n    return binaryClosest(offsets, scrollTop)\n  }\n\n  let lastScrollTop = 0\n  let scrollVelocity = 0\n  let lastScrollTime = 0\n\n  watch(viewportHeight, (val, oldVal) => {\n    if (oldVal) {\n      calculateVisibleItems()\n      if (val < oldVal) {\n        requestAnimationFrame(() => {\n          scrollVelocity = 0\n          calculateVisibleItems()\n        })\n      }\n    }\n  })\n\n  let scrollTimeout = -1\n  function handleScroll () {\n    if (!containerRef.value || !markerRef.value) return\n\n    const scrollTop = containerRef.value.scrollTop\n    const scrollTime = performance.now()\n    const scrollDeltaT = scrollTime - lastScrollTime\n\n    if (scrollDeltaT > 500) {\n      scrollVelocity = Math.sign(scrollTop - lastScrollTop)\n\n      // Not super important, only update at the\n      // start of a scroll sequence to avoid reflows\n      markerOffset = markerRef.value.offsetTop\n    } else {\n      scrollVelocity = scrollTop - lastScrollTop\n    }\n\n    lastScrollTop = scrollTop\n    lastScrollTime = scrollTime\n\n    window.clearTimeout(scrollTimeout)\n    scrollTimeout = window.setTimeout(handleScrollend, 500)\n\n    calculateVisibleItems()\n  }\n  function handleScrollend () {\n    if (!containerRef.value || !markerRef.value) return\n\n    scrollVelocity = 0\n    lastScrollTime = 0\n\n    window.clearTimeout(scrollTimeout)\n    calculateVisibleItems()\n  }\n\n  let raf = -1\n  function calculateVisibleItems () {\n    cancelAnimationFrame(raf)\n    raf = requestAnimationFrame(_calculateVisibleItems)\n  }\n  function _calculateVisibleItems () {\n    if (!containerRef.value || !viewportHeight.value || !itemHeight.value) return\n    const scrollTop = lastScrollTop - markerOffset\n    const direction = Math.sign(scrollVelocity)\n\n    const startPx = Math.max(0, scrollTop - BUFFER_PX)\n    const start = clamp(calculateIndex(startPx), 0, items.value.length)\n\n    const endPx = scrollTop + viewportHeight.value + BUFFER_PX\n    const end = clamp(calculateIndex(endPx) + 1, start + 1, items.value.length)\n\n    if (\n      // Only update the side we're scrolling towards,\n      // the other side will be updated incidentally\n      (direction !== UP || start < first.value) &&\n      (direction !== DOWN || end > last.value)\n    ) {\n      const topOverflow = calculateOffset(first.value) - calculateOffset(start)\n      const bottomOverflow = calculateOffset(end) - calculateOffset(last.value)\n      const bufferOverflow = Math.max(topOverflow, bottomOverflow)\n\n      if (bufferOverflow > BUFFER_PX) {\n        first.value = start\n        last.value = end\n      } else {\n        // Only update the side that's reached its limit if there's still buffer left\n        if (start <= 0) first.value = start\n        if (end >= items.value.length) last.value = end\n      }\n    }\n\n    paddingTop.value = calculateOffset(first.value)\n    paddingBottom.value = calculateOffset(items.value.length) - calculateOffset(last.value)\n  }\n\n  function scrollToIndex (index: number) {\n    const offset = calculateOffset(index)\n    if (!containerRef.value || (index && !offset)) {\n      targetScrollIndex = index\n    } else {\n      containerRef.value.scrollTop = offset\n    }\n  }\n\n  const computedItems = computed(() => {\n    return items.value.slice(first.value, last.value).map((item, index) => {\n      const _index = index + first.value\n      return {\n        raw: item,\n        index: _index,\n        key: getPropertyFromItem(item, props.itemKey, _index),\n      }\n    })\n  })\n\n  watch(items, () => {\n    sizes = Array.from({ length: items.value.length })\n    offsets = Array.from({ length: items.value.length })\n    updateOffsets.immediate()\n    calculateVisibleItems()\n  }, { deep: 1 })\n\n  return {\n    calculateVisibleItems,\n    containerRef,\n    markerRef,\n    computedItems,\n    paddingTop,\n    paddingBottom,\n    scrollToIndex,\n    handleScroll,\n    handleScrollend,\n    handleItemResize,\n  }\n}\n\n// https://gist.github.com/robertleeplummerjr/1cc657191d34ecd0a324\nfunction binaryClosest (arr: ArrayLike<number>, val: number) {\n  let high = arr.length - 1\n  let low = 0\n  let mid = 0\n  let item = null\n  let target = -1\n\n  if (arr[high]! < val) {\n    return high\n  }\n\n  while (low <= high) {\n    mid = (low + high) >> 1\n    item = arr[mid]!\n\n    if (item > val) {\n      high = mid - 1\n    } else if (item < val) {\n      target = mid\n      low = mid + 1\n    } else if (item === val) {\n      return mid\n    } else {\n      return low\n    }\n  }\n\n  return target\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}