{"ast":null,"code":"import _objectSpread from \"/home/idea/td_test/LAZYPIC/PONO/web_test/fast_vue/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"/home/idea/td_test/LAZYPIC/PONO/web_test/fast_vue/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _defineProperty from \"/home/idea/td_test/LAZYPIC/PONO/web_test/fast_vue/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport \"core-js/modules/es.array.at.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.string.at-alternative.js\";\nimport \"core-js/modules/es.string.anchor.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n// Composables\nimport { useToggleScope } from \"../../composables/toggleScope.js\"; // Utilities\nimport { computed, nextTick, onScopeDispose, ref, watch } from 'vue';\nimport { anchorToPoint, getOffset } from \"./util/point.js\";\nimport { CircularBuffer, clamp, consoleError, convertToUnit, deepEqual, destructComputed, flipAlign, flipCorner, flipSide, getAxis, getScrollParents, IN_BROWSER, isFixedPosition, nullifyTransforms, parseAnchor, propsFactory } from \"../../util/index.js\";\nimport { Box, getElementBox, getOverflow, getTargetBox } from \"../../util/box.js\"; // Types\nvar locationStrategies = {\n  \"static\": staticLocationStrategy,\n  // specific viewport position, usually centered\n  connected: connectedLocationStrategy // connected to a certain element\n};\nexport var makeLocationStrategyProps = propsFactory({\n  locationStrategy: {\n    type: [String, Function],\n    \"default\": 'static',\n    validator: function validator(val) {\n      return typeof val === 'function' || val in locationStrategies;\n    }\n  },\n  location: {\n    type: String,\n    \"default\": 'bottom'\n  },\n  origin: {\n    type: String,\n    \"default\": 'auto'\n  },\n  offset: [Number, String, Array]\n}, 'VOverlay-location-strategies');\nexport function useLocationStrategies(props, data) {\n  var contentStyles = ref({});\n  var updateLocation = ref();\n  if (IN_BROWSER) {\n    useToggleScope(function () {\n      return !!(data.isActive.value && props.locationStrategy);\n    }, function (reset) {\n      var _visualViewport3, _visualViewport4;\n      watch(function () {\n        return props.locationStrategy;\n      }, reset);\n      onScopeDispose(function () {\n        var _visualViewport, _visualViewport2;\n        window.removeEventListener('resize', onResize);\n        (_visualViewport = visualViewport) === null || _visualViewport === void 0 || _visualViewport.removeEventListener('resize', onVisualResize);\n        (_visualViewport2 = visualViewport) === null || _visualViewport2 === void 0 || _visualViewport2.removeEventListener('scroll', onVisualScroll);\n        updateLocation.value = undefined;\n      });\n      window.addEventListener('resize', onResize, {\n        passive: true\n      });\n      (_visualViewport3 = visualViewport) === null || _visualViewport3 === void 0 || _visualViewport3.addEventListener('resize', onVisualResize, {\n        passive: true\n      });\n      (_visualViewport4 = visualViewport) === null || _visualViewport4 === void 0 || _visualViewport4.addEventListener('scroll', onVisualScroll, {\n        passive: true\n      });\n      if (typeof props.locationStrategy === 'function') {\n        var _props$locationStrate;\n        updateLocation.value = (_props$locationStrate = props.locationStrategy(data, props, contentStyles)) === null || _props$locationStrate === void 0 ? void 0 : _props$locationStrate.updateLocation;\n      } else {\n        var _locationStrategies$p;\n        updateLocation.value = (_locationStrategies$p = locationStrategies[props.locationStrategy](data, props, contentStyles)) === null || _locationStrategies$p === void 0 ? void 0 : _locationStrategies$p.updateLocation;\n      }\n    });\n  }\n  function onResize(e) {\n    var _updateLocation$value;\n    (_updateLocation$value = updateLocation.value) === null || _updateLocation$value === void 0 || _updateLocation$value.call(updateLocation, e);\n  }\n  function onVisualResize(e) {\n    var _updateLocation$value2;\n    (_updateLocation$value2 = updateLocation.value) === null || _updateLocation$value2 === void 0 || _updateLocation$value2.call(updateLocation, e);\n  }\n  function onVisualScroll(e) {\n    var _updateLocation$value3;\n    (_updateLocation$value3 = updateLocation.value) === null || _updateLocation$value3 === void 0 || _updateLocation$value3.call(updateLocation, e);\n  }\n  return {\n    contentStyles: contentStyles,\n    updateLocation: updateLocation\n  };\n}\nfunction staticLocationStrategy() {\n  // TODO\n}\n\n/** Get size of element ignoring max-width/max-height */\nfunction getIntrinsicSize(el, isRtl) {\n  // const scrollables = new Map<Element, [number, number]>()\n  // el.querySelectorAll('*').forEach(el => {\n  //   const x = el.scrollLeft\n  //   const y = el.scrollTop\n  //   if (x || y) {\n  //     scrollables.set(el, [x, y])\n  //   }\n  // })\n\n  // const initialMaxWidth = el.style.maxWidth\n  // const initialMaxHeight = el.style.maxHeight\n  // el.style.removeProperty('max-width')\n  // el.style.removeProperty('max-height')\n\n  /* eslint-disable-next-line sonarjs/prefer-immediate-return */\n  var contentBox = nullifyTransforms(el);\n  if (isRtl) {\n    contentBox.x += parseFloat(el.style.right || 0);\n  } else {\n    contentBox.x -= parseFloat(el.style.left || 0);\n  }\n  contentBox.y -= parseFloat(el.style.top || 0);\n\n  // el.style.maxWidth = initialMaxWidth\n  // el.style.maxHeight = initialMaxHeight\n  // scrollables.forEach((position, el) => {\n  //   el.scrollTo(...position)\n  // })\n\n  return contentBox;\n}\nfunction connectedLocationStrategy(data, props, contentStyles) {\n  var activatorFixed = Array.isArray(data.target.value) || isFixedPosition(data.target.value);\n  if (activatorFixed) {\n    Object.assign(contentStyles.value, _defineProperty({\n      position: 'fixed',\n      top: 0\n    }, data.isRtl.value ? 'right' : 'left', 0));\n  }\n  var _destructComputed = destructComputed(function () {\n      var parsedAnchor = parseAnchor(props.location, data.isRtl.value);\n      var parsedOrigin = props.origin === 'overlap' ? parsedAnchor : props.origin === 'auto' ? flipSide(parsedAnchor) : parseAnchor(props.origin, data.isRtl.value);\n\n      // Some combinations of props may produce an invalid origin\n      if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === flipAlign(parsedOrigin).align) {\n        return {\n          preferredAnchor: flipCorner(parsedAnchor),\n          preferredOrigin: flipCorner(parsedOrigin)\n        };\n      } else {\n        return {\n          preferredAnchor: parsedAnchor,\n          preferredOrigin: parsedOrigin\n        };\n      }\n    }),\n    preferredAnchor = _destructComputed.preferredAnchor,\n    preferredOrigin = _destructComputed.preferredOrigin;\n  var _map = ['minWidth', 'minHeight', 'maxWidth', 'maxHeight'].map(function (key) {\n      return computed(function () {\n        var val = parseFloat(props[key]);\n        return isNaN(val) ? Infinity : val;\n      });\n    }),\n    _map2 = _slicedToArray(_map, 4),\n    minWidth = _map2[0],\n    minHeight = _map2[1],\n    maxWidth = _map2[2],\n    maxHeight = _map2[3];\n  var offset = computed(function () {\n    if (Array.isArray(props.offset)) {\n      return props.offset;\n    }\n    if (typeof props.offset === 'string') {\n      var _offset = props.offset.split(' ').map(parseFloat);\n      if (_offset.length < 2) _offset.push(0);\n      return _offset;\n    }\n    return typeof props.offset === 'number' ? [props.offset, 0] : [0, 0];\n  });\n  var observe = false;\n  var lastFrame = -1;\n  var flipped = new CircularBuffer(4);\n  var observer = new ResizeObserver(function () {\n    if (!observe) return;\n\n    // Detect consecutive frames\n    requestAnimationFrame(function (newTime) {\n      if (newTime !== lastFrame) flipped.clear();\n      requestAnimationFrame(function (newNewTime) {\n        lastFrame = newNewTime;\n      });\n    });\n    if (flipped.isFull) {\n      var values = flipped.values();\n      if (deepEqual(values.at(-1), values.at(-3)) && !deepEqual(values.at(-1), values.at(-2))) {\n        // Flipping is causing a container resize loop\n        return;\n      }\n    }\n    var result = updateLocation();\n    if (result) flipped.push(result.flipped);\n  });\n  watch([data.target, data.contentEl], function (_ref, _ref2) {\n    var _ref3 = _slicedToArray(_ref, 2),\n      newTarget = _ref3[0],\n      newContentEl = _ref3[1];\n    var _ref4 = _slicedToArray(_ref2, 2),\n      oldTarget = _ref4[0],\n      oldContentEl = _ref4[1];\n    if (oldTarget && !Array.isArray(oldTarget)) observer.unobserve(oldTarget);\n    if (newTarget && !Array.isArray(newTarget)) observer.observe(newTarget);\n    if (oldContentEl) observer.unobserve(oldContentEl);\n    if (newContentEl) observer.observe(newContentEl);\n  }, {\n    immediate: true\n  });\n  onScopeDispose(function () {\n    observer.disconnect();\n  });\n  var targetBox = new Box({\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  });\n\n  // eslint-disable-next-line max-statements\n  function updateLocation() {\n    observe = false;\n    requestAnimationFrame(function () {\n      return observe = true;\n    });\n    if (!data.target.value || !data.contentEl.value) return;\n    if (Array.isArray(data.target.value) || data.target.value.offsetParent || data.target.value.getClientRects().length) {\n      targetBox = getTargetBox(data.target.value);\n    } // Otherwise target element is hidden, use last known value\n\n    var contentBox = getIntrinsicSize(data.contentEl.value, data.isRtl.value);\n    var scrollParents = getScrollParents(data.contentEl.value);\n    var viewportMargin = 12;\n    if (!scrollParents.length) {\n      scrollParents.push(document.documentElement);\n      if (!(data.contentEl.value.style.top && data.contentEl.value.style.left)) {\n        contentBox.x -= parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-x') || 0);\n        contentBox.y -= parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-y') || 0);\n      }\n    }\n    var viewport = scrollParents.reduce(function (box, el) {\n      var scrollBox = getElementBox(el);\n      if (box) {\n        return new Box({\n          x: Math.max(box.left, scrollBox.left),\n          y: Math.max(box.top, scrollBox.top),\n          width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),\n          height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top)\n        });\n      }\n      return scrollBox;\n    }, undefined);\n    viewport.x += viewportMargin;\n    viewport.y += viewportMargin;\n    viewport.width -= viewportMargin * 2;\n    viewport.height -= viewportMargin * 2;\n    var placement = {\n      anchor: preferredAnchor.value,\n      origin: preferredOrigin.value\n    };\n    function checkOverflow(_placement) {\n      var box = new Box(contentBox);\n      var targetPoint = anchorToPoint(_placement.anchor, targetBox);\n      var contentPoint = anchorToPoint(_placement.origin, box);\n      var _getOffset = getOffset(targetPoint, contentPoint),\n        x = _getOffset.x,\n        y = _getOffset.y;\n      switch (_placement.anchor.side) {\n        case 'top':\n          y -= offset.value[0];\n          break;\n        case 'bottom':\n          y += offset.value[0];\n          break;\n        case 'left':\n          x -= offset.value[0];\n          break;\n        case 'right':\n          x += offset.value[0];\n          break;\n      }\n      switch (_placement.anchor.align) {\n        case 'top':\n          y -= offset.value[1];\n          break;\n        case 'bottom':\n          y += offset.value[1];\n          break;\n        case 'left':\n          x -= offset.value[1];\n          break;\n        case 'right':\n          x += offset.value[1];\n          break;\n      }\n      box.x += x;\n      box.y += y;\n      box.width = Math.min(box.width, maxWidth.value);\n      box.height = Math.min(box.height, maxHeight.value);\n      var overflows = getOverflow(box, viewport);\n      return {\n        overflows: overflows,\n        x: x,\n        y: y\n      };\n    }\n    var x = 0;\n    var y = 0;\n    var available = {\n      x: 0,\n      y: 0\n    };\n    var flipped = {\n      x: false,\n      y: false\n    };\n    var resets = -1;\n    var _loop = function _loop() {\n        if (resets++ > 10) {\n          consoleError('Infinite loop detected in connectedLocationStrategy');\n          return 0; // break\n        }\n        var _checkOverflow = checkOverflow(placement),\n          _x = _checkOverflow.x,\n          _y = _checkOverflow.y,\n          overflows = _checkOverflow.overflows;\n        x += _x;\n        y += _y;\n        contentBox.x += _x;\n        contentBox.y += _y;\n\n        // flip\n        {\n          var _axis = getAxis(placement.anchor);\n          var hasOverflowX = overflows.x.before || overflows.x.after;\n          var hasOverflowY = overflows.y.before || overflows.y.after;\n          var reset = false;\n          ['x', 'y'].forEach(function (key) {\n            if (key === 'x' && hasOverflowX && !flipped.x || key === 'y' && hasOverflowY && !flipped.y) {\n              var newPlacement = {\n                anchor: _objectSpread({}, placement.anchor),\n                origin: _objectSpread({}, placement.origin)\n              };\n              var flip = key === 'x' ? _axis === 'y' ? flipAlign : flipSide : _axis === 'y' ? flipSide : flipAlign;\n              newPlacement.anchor = flip(newPlacement.anchor);\n              newPlacement.origin = flip(newPlacement.origin);\n              var _checkOverflow2 = checkOverflow(newPlacement),\n                newOverflows = _checkOverflow2.overflows;\n              if (newOverflows[key].before <= overflows[key].before && newOverflows[key].after <= overflows[key].after || newOverflows[key].before + newOverflows[key].after < (overflows[key].before + overflows[key].after) / 2) {\n                placement = newPlacement;\n                reset = flipped[key] = true;\n              }\n            }\n          });\n          if (reset) return 1; // continue\n        }\n\n        // shift\n        if (overflows.x.before) {\n          x += overflows.x.before;\n          contentBox.x += overflows.x.before;\n        }\n        if (overflows.x.after) {\n          x -= overflows.x.after;\n          contentBox.x -= overflows.x.after;\n        }\n        if (overflows.y.before) {\n          y += overflows.y.before;\n          contentBox.y += overflows.y.before;\n        }\n        if (overflows.y.after) {\n          y -= overflows.y.after;\n          contentBox.y -= overflows.y.after;\n        }\n\n        // size\n        {\n          var _overflows = getOverflow(contentBox, viewport);\n          available.x = viewport.width - _overflows.x.before - _overflows.x.after;\n          available.y = viewport.height - _overflows.y.before - _overflows.y.after;\n          x += _overflows.x.before;\n          contentBox.x += _overflows.x.before;\n          y += _overflows.y.before;\n          contentBox.y += _overflows.y.before;\n        }\n        return 0; // break\n      },\n      _ret;\n    while (true) {\n      _ret = _loop();\n      if (_ret === 0) break;\n      if (_ret === 1) continue;\n    }\n    var axis = getAxis(placement.anchor);\n    Object.assign(contentStyles.value, {\n      '--v-overlay-anchor-origin': \"\".concat(placement.anchor.side, \" \").concat(placement.anchor.align),\n      transformOrigin: \"\".concat(placement.origin.side, \" \").concat(placement.origin.align),\n      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,\n      top: convertToUnit(pixelRound(y)),\n      left: data.isRtl.value ? undefined : convertToUnit(pixelRound(x)),\n      right: data.isRtl.value ? convertToUnit(pixelRound(-x)) : undefined,\n      minWidth: convertToUnit(axis === 'y' ? Math.min(minWidth.value, targetBox.width) : minWidth.value),\n      maxWidth: convertToUnit(pixelCeil(clamp(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),\n      maxHeight: convertToUnit(pixelCeil(clamp(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value)))\n    });\n    return {\n      available: available,\n      contentBox: contentBox,\n      flipped: flipped\n    };\n  }\n  watch(function () {\n    return [preferredAnchor.value, preferredOrigin.value, props.offset, props.minWidth, props.minHeight, props.maxWidth, props.maxHeight];\n  }, function () {\n    return updateLocation();\n  });\n  nextTick(function () {\n    var result = updateLocation();\n\n    // TODO: overflowing content should only require a single updateLocation call\n    // Icky hack to make sure the content is positioned consistently\n    if (!result) return;\n    var available = result.available,\n      contentBox = result.contentBox;\n    if (contentBox.height > available.y) {\n      requestAnimationFrame(function () {\n        updateLocation();\n        requestAnimationFrame(function () {\n          updateLocation();\n        });\n      });\n    }\n  });\n  return {\n    updateLocation: updateLocation\n  };\n}\nfunction pixelRound(val) {\n  return Math.round(val * devicePixelRatio) / devicePixelRatio;\n}\nfunction pixelCeil(val) {\n  return Math.ceil(val * devicePixelRatio) / devicePixelRatio;\n}","map":{"version":3,"names":["useToggleScope","computed","nextTick","onScopeDispose","ref","watch","anchorToPoint","getOffset","CircularBuffer","clamp","consoleError","convertToUnit","deepEqual","destructComputed","flipAlign","flipCorner","flipSide","getAxis","getScrollParents","IN_BROWSER","isFixedPosition","nullifyTransforms","parseAnchor","propsFactory","Box","getElementBox","getOverflow","getTargetBox","locationStrategies","staticLocationStrategy","connected","connectedLocationStrategy","makeLocationStrategyProps","locationStrategy","type","String","Function","validator","val","location","origin","offset","Number","Array","useLocationStrategies","props","data","contentStyles","updateLocation","isActive","value","reset","_visualViewport3","_visualViewport4","_visualViewport","_visualViewport2","window","removeEventListener","onResize","visualViewport","onVisualResize","onVisualScroll","undefined","addEventListener","passive","_props$locationStrate","_locationStrategies$p","e","_updateLocation$value","call","_updateLocation$value2","_updateLocation$value3","getIntrinsicSize","el","isRtl","contentBox","x","parseFloat","style","right","left","y","top","activatorFixed","isArray","target","Object","assign","_defineProperty","position","_destructComputed","parsedAnchor","parsedOrigin","side","align","preferredAnchor","preferredOrigin","_map","map","key","isNaN","Infinity","_map2","_slicedToArray","minWidth","minHeight","maxWidth","maxHeight","split","length","push","observe","lastFrame","flipped","observer","ResizeObserver","requestAnimationFrame","newTime","clear","newNewTime","isFull","values","at","result","contentEl","_ref","_ref2","_ref3","newTarget","newContentEl","_ref4","oldTarget","oldContentEl","unobserve","immediate","disconnect","targetBox","width","height","offsetParent","getClientRects","scrollParents","viewportMargin","document","documentElement","getPropertyValue","viewport","reduce","box","scrollBox","Math","max","min","bottom","placement","anchor","checkOverflow","_placement","targetPoint","contentPoint","_getOffset","overflows","available","resets","_loop","_checkOverflow","_x","_y","axis","hasOverflowX","before","after","hasOverflowY","forEach","newPlacement","_objectSpread","flip","_checkOverflow2","newOverflows","_ret","concat","transformOrigin","pixelRound","pixelCeil","round","devicePixelRatio","ceil"],"sources":["../../../src/components/VOverlay/locationStrategies.ts"],"sourcesContent":["// Composables\nimport { useToggleScope } from '@/composables/toggleScope'\n\n// Utilities\nimport { computed, nextTick, onScopeDispose, ref, watch } from 'vue'\nimport { anchorToPoint, getOffset } from './util/point'\nimport {\n  CircularBuffer,\n  clamp,\n  consoleError,\n  convertToUnit,\n  deepEqual,\n  destructComputed,\n  flipAlign,\n  flipCorner,\n  flipSide,\n  getAxis,\n  getScrollParents,\n  IN_BROWSER,\n  isFixedPosition,\n  nullifyTransforms,\n  parseAnchor,\n  propsFactory,\n} from '@/util'\nimport { Box, getElementBox, getOverflow, getTargetBox } from '@/util/box'\n\n// Types\nimport type { PropType, Ref } from 'vue'\nimport type { Anchor } from '@/util'\n\nexport interface LocationStrategyData {\n  contentEl: Ref<HTMLElement | undefined>\n  target: Ref<HTMLElement | [x: number, y: number] | undefined>\n  isActive: Ref<boolean>\n  isRtl: Ref<boolean>\n}\n\nexport type LocationStrategyFunction = (\n  data: LocationStrategyData,\n  props: StrategyProps,\n  contentStyles: Ref<Record<string, string>>\n) => undefined | { updateLocation: (e?: Event) => void }\n\nconst locationStrategies = {\n  static: staticLocationStrategy, // specific viewport position, usually centered\n  connected: connectedLocationStrategy, // connected to a certain element\n}\n\nexport interface StrategyProps {\n  locationStrategy: keyof typeof locationStrategies | LocationStrategyFunction\n  location: Anchor\n  origin: Anchor | 'auto' | 'overlap'\n  offset?: number | string | number[]\n  maxHeight?: number | string\n  maxWidth?: number | string\n  minHeight?: number | string\n  minWidth?: number | string\n}\n\nexport const makeLocationStrategyProps = propsFactory({\n  locationStrategy: {\n    type: [String, Function] as PropType<StrategyProps['locationStrategy']>,\n    default: 'static',\n    validator: (val: any) => typeof val === 'function' || val in locationStrategies,\n  },\n  location: {\n    type: String as PropType<StrategyProps['location']>,\n    default: 'bottom',\n  },\n  origin: {\n    type: String as PropType<StrategyProps['origin']>,\n    default: 'auto',\n  },\n  offset: [Number, String, Array] as PropType<StrategyProps['offset']>,\n}, 'VOverlay-location-strategies')\n\nexport function useLocationStrategies (\n  props: StrategyProps,\n  data: LocationStrategyData\n) {\n  const contentStyles = ref({})\n  const updateLocation = ref<(e: Event) => void>()\n\n  if (IN_BROWSER) {\n    useToggleScope(() => !!(data.isActive.value && props.locationStrategy), reset => {\n      watch(() => props.locationStrategy, reset)\n      onScopeDispose(() => {\n        window.removeEventListener('resize', onResize)\n        visualViewport?.removeEventListener('resize', onVisualResize)\n        visualViewport?.removeEventListener('scroll', onVisualScroll)\n        updateLocation.value = undefined\n      })\n\n      window.addEventListener('resize', onResize, { passive: true })\n      visualViewport?.addEventListener('resize', onVisualResize, { passive: true })\n      visualViewport?.addEventListener('scroll', onVisualScroll, { passive: true })\n\n      if (typeof props.locationStrategy === 'function') {\n        updateLocation.value = props.locationStrategy(data, props, contentStyles)?.updateLocation\n      } else {\n        updateLocation.value = locationStrategies[props.locationStrategy](data, props, contentStyles)?.updateLocation\n      }\n    })\n  }\n\n  function onResize (e: Event) {\n    updateLocation.value?.(e)\n  }\n\n  function onVisualResize (e: Event) {\n    updateLocation.value?.(e)\n  }\n\n  function onVisualScroll (e: Event) {\n    updateLocation.value?.(e)\n  }\n\n  return {\n    contentStyles,\n    updateLocation,\n  }\n}\n\nfunction staticLocationStrategy () {\n  // TODO\n}\n\n/** Get size of element ignoring max-width/max-height */\nfunction getIntrinsicSize (el: HTMLElement, isRtl: boolean) {\n  // const scrollables = new Map<Element, [number, number]>()\n  // el.querySelectorAll('*').forEach(el => {\n  //   const x = el.scrollLeft\n  //   const y = el.scrollTop\n  //   if (x || y) {\n  //     scrollables.set(el, [x, y])\n  //   }\n  // })\n\n  // const initialMaxWidth = el.style.maxWidth\n  // const initialMaxHeight = el.style.maxHeight\n  // el.style.removeProperty('max-width')\n  // el.style.removeProperty('max-height')\n\n  /* eslint-disable-next-line sonarjs/prefer-immediate-return */\n  const contentBox = nullifyTransforms(el)\n\n  if (isRtl) {\n    contentBox.x += parseFloat(el.style.right || 0)\n  } else {\n    contentBox.x -= parseFloat(el.style.left || 0)\n  }\n  contentBox.y -= parseFloat(el.style.top || 0)\n\n  // el.style.maxWidth = initialMaxWidth\n  // el.style.maxHeight = initialMaxHeight\n  // scrollables.forEach((position, el) => {\n  //   el.scrollTo(...position)\n  // })\n\n  return contentBox\n}\n\nfunction connectedLocationStrategy (data: LocationStrategyData, props: StrategyProps, contentStyles: Ref<Record<string, string>>) {\n  const activatorFixed = Array.isArray(data.target.value) || isFixedPosition(data.target.value)\n  if (activatorFixed) {\n    Object.assign(contentStyles.value, {\n      position: 'fixed',\n      top: 0,\n      [data.isRtl.value ? 'right' : 'left']: 0,\n    })\n  }\n\n  const { preferredAnchor, preferredOrigin } = destructComputed(() => {\n    const parsedAnchor = parseAnchor(props.location, data.isRtl.value)\n    const parsedOrigin =\n      props.origin === 'overlap' ? parsedAnchor\n      : props.origin === 'auto' ? flipSide(parsedAnchor)\n      : parseAnchor(props.origin, data.isRtl.value)\n\n    // Some combinations of props may produce an invalid origin\n    if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === flipAlign(parsedOrigin).align) {\n      return {\n        preferredAnchor: flipCorner(parsedAnchor),\n        preferredOrigin: flipCorner(parsedOrigin),\n      }\n    } else {\n      return {\n        preferredAnchor: parsedAnchor,\n        preferredOrigin: parsedOrigin,\n      }\n    }\n  })\n\n  const [minWidth, minHeight, maxWidth, maxHeight] =\n    (['minWidth', 'minHeight', 'maxWidth', 'maxHeight'] as const).map(key => {\n      return computed(() => {\n        const val = parseFloat(props[key]!)\n        return isNaN(val) ? Infinity : val\n      })\n    })\n\n  const offset = computed(() => {\n    if (Array.isArray(props.offset)) {\n      return props.offset\n    }\n    if (typeof props.offset === 'string') {\n      const offset = props.offset.split(' ').map(parseFloat)\n      if (offset.length < 2) offset.push(0)\n      return offset\n    }\n    return typeof props.offset === 'number' ? [props.offset, 0] : [0, 0]\n  })\n\n  let observe = false\n  let lastFrame = -1\n  const flipped = new CircularBuffer<{ x: boolean, y: boolean }>(4)\n  const observer = new ResizeObserver(() => {\n    if (!observe) return\n\n    // Detect consecutive frames\n    requestAnimationFrame(newTime => {\n      if (newTime !== lastFrame) flipped.clear()\n      requestAnimationFrame(newNewTime => {\n        lastFrame = newNewTime\n      })\n    })\n\n    if (flipped.isFull) {\n      const values = flipped.values()\n      if (\n        deepEqual(values.at(-1), values.at(-3)) &&\n        !deepEqual(values.at(-1), values.at(-2))\n      ) {\n        // Flipping is causing a container resize loop\n        return\n      }\n    }\n\n    const result = updateLocation()\n    if (result) flipped.push(result.flipped)\n  })\n\n  watch([data.target, data.contentEl], ([newTarget, newContentEl], [oldTarget, oldContentEl]) => {\n    if (oldTarget && !Array.isArray(oldTarget)) observer.unobserve(oldTarget)\n    if (newTarget && !Array.isArray(newTarget)) observer.observe(newTarget)\n\n    if (oldContentEl) observer.unobserve(oldContentEl)\n    if (newContentEl) observer.observe(newContentEl)\n  }, {\n    immediate: true,\n  })\n\n  onScopeDispose(() => {\n    observer.disconnect()\n  })\n\n  let targetBox = new Box({ x: 0, y: 0, width: 0, height: 0 })\n\n  // eslint-disable-next-line max-statements\n  function updateLocation () {\n    observe = false\n    requestAnimationFrame(() => observe = true)\n\n    if (!data.target.value || !data.contentEl.value) return\n\n    if (\n      Array.isArray(data.target.value) ||\n      data.target.value.offsetParent ||\n      data.target.value.getClientRects().length\n    ) {\n      targetBox = getTargetBox(data.target.value)\n    } // Otherwise target element is hidden, use last known value\n\n    const contentBox = getIntrinsicSize(data.contentEl.value, data.isRtl.value)\n    const scrollParents = getScrollParents(data.contentEl.value)\n    const viewportMargin = 12\n\n    if (!scrollParents.length) {\n      scrollParents.push(document.documentElement)\n      if (!(data.contentEl.value.style.top && data.contentEl.value.style.left)) {\n        contentBox.x -= parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-x') || 0)\n        contentBox.y -= parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-y') || 0)\n      }\n    }\n\n    const viewport = scrollParents.reduce<Box>((box: Box | undefined, el) => {\n      const scrollBox = getElementBox(el)\n\n      if (box) {\n        return new Box({\n          x: Math.max(box.left, scrollBox.left),\n          y: Math.max(box.top, scrollBox.top),\n          width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),\n          height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top),\n        })\n      }\n      return scrollBox\n    }, undefined!)\n    viewport.x += viewportMargin\n    viewport.y += viewportMargin\n    viewport.width -= viewportMargin * 2\n    viewport.height -= viewportMargin * 2\n\n    let placement = {\n      anchor: preferredAnchor.value,\n      origin: preferredOrigin.value,\n    }\n\n    function checkOverflow (_placement: typeof placement) {\n      const box = new Box(contentBox)\n      const targetPoint = anchorToPoint(_placement.anchor, targetBox)\n      const contentPoint = anchorToPoint(_placement.origin, box)\n\n      let { x, y } = getOffset(targetPoint, contentPoint)\n\n      switch (_placement.anchor.side) {\n        case 'top': y -= offset.value[0]; break\n        case 'bottom': y += offset.value[0]; break\n        case 'left': x -= offset.value[0]; break\n        case 'right': x += offset.value[0]; break\n      }\n\n      switch (_placement.anchor.align) {\n        case 'top': y -= offset.value[1]; break\n        case 'bottom': y += offset.value[1]; break\n        case 'left': x -= offset.value[1]; break\n        case 'right': x += offset.value[1]; break\n      }\n\n      box.x += x\n      box.y += y\n\n      box.width = Math.min(box.width, maxWidth.value)\n      box.height = Math.min(box.height, maxHeight.value)\n\n      const overflows = getOverflow(box, viewport)\n\n      return { overflows, x, y }\n    }\n\n    let x = 0; let y = 0\n    const available = { x: 0, y: 0 }\n    const flipped = { x: false, y: false }\n    let resets = -1\n    while (true) {\n      if (resets++ > 10) {\n        consoleError('Infinite loop detected in connectedLocationStrategy')\n        break\n      }\n\n      const { x: _x, y: _y, overflows } = checkOverflow(placement)\n\n      x += _x\n      y += _y\n\n      contentBox.x += _x\n      contentBox.y += _y\n\n      // flip\n      {\n        const axis = getAxis(placement.anchor)\n        const hasOverflowX = overflows.x.before || overflows.x.after\n        const hasOverflowY = overflows.y.before || overflows.y.after\n\n        let reset = false\n        ;['x', 'y'].forEach(key => {\n          if (\n            (key === 'x' && hasOverflowX && !flipped.x) ||\n            (key === 'y' && hasOverflowY && !flipped.y)\n          ) {\n            const newPlacement = { anchor: { ...placement.anchor }, origin: { ...placement.origin } }\n            const flip = key === 'x'\n              ? axis === 'y' ? flipAlign : flipSide\n              : axis === 'y' ? flipSide : flipAlign\n            newPlacement.anchor = flip(newPlacement.anchor)\n            newPlacement.origin = flip(newPlacement.origin)\n            const { overflows: newOverflows } = checkOverflow(newPlacement)\n            if (\n              (newOverflows[key].before <= overflows[key].before &&\n                newOverflows[key].after <= overflows[key].after) ||\n              (newOverflows[key].before + newOverflows[key].after <\n                (overflows[key].before + overflows[key].after) / 2)\n            ) {\n              placement = newPlacement\n              reset = flipped[key] = true\n            }\n          }\n        })\n        if (reset) continue\n      }\n\n      // shift\n      if (overflows.x.before) {\n        x += overflows.x.before\n        contentBox.x += overflows.x.before\n      }\n      if (overflows.x.after) {\n        x -= overflows.x.after\n        contentBox.x -= overflows.x.after\n      }\n      if (overflows.y.before) {\n        y += overflows.y.before\n        contentBox.y += overflows.y.before\n      }\n      if (overflows.y.after) {\n        y -= overflows.y.after\n        contentBox.y -= overflows.y.after\n      }\n\n      // size\n      {\n        const overflows = getOverflow(contentBox, viewport)\n        available.x = viewport.width - overflows.x.before - overflows.x.after\n        available.y = viewport.height - overflows.y.before - overflows.y.after\n\n        x += overflows.x.before\n        contentBox.x += overflows.x.before\n        y += overflows.y.before\n        contentBox.y += overflows.y.before\n      }\n\n      break\n    }\n\n    const axis = getAxis(placement.anchor)\n\n    Object.assign(contentStyles.value, {\n      '--v-overlay-anchor-origin': `${placement.anchor.side} ${placement.anchor.align}`,\n      transformOrigin: `${placement.origin.side} ${placement.origin.align}`,\n      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,\n      top: convertToUnit(pixelRound(y)),\n      left: data.isRtl.value ? undefined : convertToUnit(pixelRound(x)),\n      right: data.isRtl.value ? convertToUnit(pixelRound(-x)) : undefined,\n      minWidth: convertToUnit(axis === 'y' ? Math.min(minWidth.value, targetBox.width) : minWidth.value),\n      maxWidth: convertToUnit(pixelCeil(clamp(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),\n      maxHeight: convertToUnit(pixelCeil(clamp(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value))),\n    })\n\n    return {\n      available,\n      contentBox,\n      flipped,\n    }\n  }\n\n  watch(\n    () => [\n      preferredAnchor.value,\n      preferredOrigin.value,\n      props.offset,\n      props.minWidth,\n      props.minHeight,\n      props.maxWidth,\n      props.maxHeight,\n    ],\n    () => updateLocation(),\n  )\n\n  nextTick(() => {\n    const result = updateLocation()\n\n    // TODO: overflowing content should only require a single updateLocation call\n    // Icky hack to make sure the content is positioned consistently\n    if (!result) return\n    const { available, contentBox } = result\n    if (contentBox.height > available.y) {\n      requestAnimationFrame(() => {\n        updateLocation()\n        requestAnimationFrame(() => {\n          updateLocation()\n        })\n      })\n    }\n  })\n\n  return { updateLocation }\n}\n\nfunction pixelRound (val: number) {\n  return Math.round(val * devicePixelRatio) / devicePixelRatio\n}\n\nfunction pixelCeil (val: number) {\n  return Math.ceil(val * devicePixelRatio) / devicePixelRatio\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AAAA,SACSA,cAAc,4CAEvB;AACA,SAASC,QAAQ,EAAEC,QAAQ,EAAEC,cAAc,EAAEC,GAAG,EAAEC,KAAK,QAAQ,KAAK;AAAA,SAC3DC,aAAa,EAAEC,SAAS;AAAA,SAE/BC,cAAc,EACdC,KAAK,EACLC,YAAY,EACZC,aAAa,EACbC,SAAS,EACTC,gBAAgB,EAChBC,SAAS,EACTC,UAAU,EACVC,QAAQ,EACRC,OAAO,EACPC,gBAAgB,EAChBC,UAAU,EACVC,eAAe,EACfC,iBAAiB,EACjBC,WAAW,EACXC,YAAY;AAAA,SAELC,GAAG,EAAEC,aAAa,EAAEC,WAAW,EAAEC,YAAY,6BAEtD;AAiBA,IAAMC,kBAAkB,GAAG;EACzB,UAAQC,sBAAsB;EAAE;EAChCC,SAAS,EAAEC,yBAAyB,CAAE;AACxC,CAAC;AAaD,OAAO,IAAMC,yBAAyB,GAAGT,YAAY,CAAC;EACpDU,gBAAgB,EAAE;IAChBC,IAAI,EAAE,CAACC,MAAM,EAAEC,QAAQ,CAAgD;IACvE,WAAS,QAAQ;IACjBC,SAAS,EAAG,SAAZA,SAASA,CAAGC,GAAQ;MAAA,OAAK,OAAOA,GAAG,KAAK,UAAU,IAAIA,GAAG,IAAIV,kBAAA;IAAA;EAC/D,CAAC;EACDW,QAAQ,EAAE;IACRL,IAAI,EAAEC,MAA6C;IACnD,WAAS;EACX,CAAC;EACDK,MAAM,EAAE;IACNN,IAAI,EAAEC,MAA2C;IACjD,WAAS;EACX,CAAC;EACDM,MAAM,EAAE,CAACC,MAAM,EAAEP,MAAM,EAAEQ,KAAK;AAChC,CAAC,EAAE,8BAA8B,CAAC;AAElC,OAAO,SAASC,qBAAqBA,CACnCC,KAAoB,EACpBC,IAA0B,EAC1B;EACA,IAAMC,aAAa,GAAG3C,GAAG,CAAC,CAAC,CAAC,CAAC;EAC7B,IAAM4C,cAAc,GAAG5C,GAAG,CAAqB,CAAC;EAEhD,IAAIe,UAAU,EAAE;IACdnB,cAAc,CAAC;MAAA,OAAM,CAAC,EAAE8C,IAAI,CAACG,QAAQ,CAACC,KAAK,IAAIL,KAAK,CAACZ,gBAAgB,CAAC;IAAA,GAAE,UAAAkB,KAAK,EAAI;MAAA,IAAAC,gBAAA,EAAAC,gBAAA;MAC/EhD,KAAK,CAAC;QAAA,OAAMwC,KAAK,CAACZ,gBAAgB;MAAA,GAAEkB,KAAK,CAAC;MAC1ChD,cAAc,CAAC,YAAM;QAAA,IAAAmD,eAAA,EAAAC,gBAAA;QACnBC,MAAM,CAACC,mBAAmB,CAAC,QAAQ,EAAEC,QAAQ,CAAC;QAC9C,CAAAJ,eAAA,GAAAK,cAAc,cAAAL,eAAA,eAAdA,eAAA,CAAgBG,mBAAmB,CAAC,QAAQ,EAAEG,cAAc,CAAC;QAC7D,CAAAL,gBAAA,GAAAI,cAAc,cAAAJ,gBAAA,eAAdA,gBAAA,CAAgBE,mBAAmB,CAAC,QAAQ,EAAEI,cAAc,CAAC;QAC7Db,cAAc,CAACE,KAAK,GAAGY,SAAS;MAClC,CAAC,CAAC;MAEFN,MAAM,CAACO,gBAAgB,CAAC,QAAQ,EAAEL,QAAQ,EAAE;QAAEM,OAAO,EAAE;MAAK,CAAC,CAAC;MAC9D,CAAAZ,gBAAA,GAAAO,cAAc,cAAAP,gBAAA,eAAdA,gBAAA,CAAgBW,gBAAgB,CAAC,QAAQ,EAAEH,cAAc,EAAE;QAAEI,OAAO,EAAE;MAAK,CAAC,CAAC;MAC7E,CAAAX,gBAAA,GAAAM,cAAc,cAAAN,gBAAA,eAAdA,gBAAA,CAAgBU,gBAAgB,CAAC,QAAQ,EAAEF,cAAc,EAAE;QAAEG,OAAO,EAAE;MAAK,CAAC,CAAC;MAE7E,IAAI,OAAOnB,KAAK,CAACZ,gBAAgB,KAAK,UAAU,EAAE;QAAA,IAAAgC,qBAAA;QAChDjB,cAAc,CAACE,KAAK,IAAAe,qBAAA,GAAGpB,KAAK,CAACZ,gBAAgB,CAACa,IAAI,EAAED,KAAK,EAAEE,aAAa,CAAC,cAAAkB,qBAAA,uBAAlDA,qBAAA,CAAoDjB,cAAc;MAC3F,CAAC,MAAM;QAAA,IAAAkB,qBAAA;QACLlB,cAAc,CAACE,KAAK,IAAAgB,qBAAA,GAAGtC,kBAAkB,CAACiB,KAAK,CAACZ,gBAAgB,CAAC,CAACa,IAAI,EAAED,KAAK,EAAEE,aAAa,CAAC,cAAAmB,qBAAA,uBAAtEA,qBAAA,CAAwElB,cAAc;MAC/G;IACF,CAAC,CAAC;EACJ;EAEA,SAASU,QAAQA,CAAES,CAAQ,EAAE;IAAA,IAAAC,qBAAA;IAC3B,CAAAA,qBAAA,GAAApB,cAAc,CAACE,KAAK,cAAAkB,qBAAA,eAApBA,qBAAA,CAAAC,IAAA,CAAArB,cAAc,EAASmB,CAAC,CAAC;EAC3B;EAEA,SAASP,cAAcA,CAAEO,CAAQ,EAAE;IAAA,IAAAG,sBAAA;IACjC,CAAAA,sBAAA,GAAAtB,cAAc,CAACE,KAAK,cAAAoB,sBAAA,eAApBA,sBAAA,CAAAD,IAAA,CAAArB,cAAc,EAASmB,CAAC,CAAC;EAC3B;EAEA,SAASN,cAAcA,CAAEM,CAAQ,EAAE;IAAA,IAAAI,sBAAA;IACjC,CAAAA,sBAAA,GAAAvB,cAAc,CAACE,KAAK,cAAAqB,sBAAA,eAApBA,sBAAA,CAAAF,IAAA,CAAArB,cAAc,EAASmB,CAAC,CAAC;EAC3B;EAEA,OAAO;IACLpB,aAAa,EAAbA,aAAa;IACbC,cAAA,EAAAA;EACF,CAAC;AACH;AAEA,SAASnB,sBAAsBA,CAAA,EAAI;EACjC;AAAA;;AAGF;AACA,SAAS2C,gBAAgBA,CAAEC,EAAe,EAAEC,KAAc,EAAE;EAC1D;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;;EAEA;EACA,IAAMC,UAAU,GAAGtD,iBAAiB,CAACoD,EAAE,CAAC;EAExC,IAAIC,KAAK,EAAE;IACTC,UAAU,CAACC,CAAC,IAAIC,UAAU,CAACJ,EAAE,CAACK,KAAK,CAACC,KAAK,IAAI,CAAC,CAAC;EACjD,CAAC,MAAM;IACLJ,UAAU,CAACC,CAAC,IAAIC,UAAU,CAACJ,EAAE,CAACK,KAAK,CAACE,IAAI,IAAI,CAAC,CAAC;EAChD;EACAL,UAAU,CAACM,CAAC,IAAIJ,UAAU,CAACJ,EAAE,CAACK,KAAK,CAACI,GAAG,IAAI,CAAC,CAAC;;EAE7C;EACA;EACA;EACA;EACA;;EAEA,OAAOP,UAAU;AACnB;AAEA,SAAS5C,yBAAyBA,CAAEe,IAA0B,EAAED,KAAoB,EAAEE,aAA0C,EAAE;EAChI,IAAMoC,cAAc,GAAGxC,KAAK,CAACyC,OAAO,CAACtC,IAAI,CAACuC,MAAM,CAACnC,KAAK,CAAC,IAAI9B,eAAe,CAAC0B,IAAI,CAACuC,MAAM,CAACnC,KAAK,CAAC;EAC7F,IAAIiC,cAAc,EAAE;IAClBG,MAAM,CAACC,MAAM,CAACxC,aAAa,CAACG,KAAK,EAAAsC,eAAA;MAC/BC,QAAQ,EAAE,OAAO;MACjBP,GAAG,EAAE;IAAC,GACLpC,IAAI,CAAC4B,KAAK,CAACxB,KAAK,GAAG,OAAO,GAAG,MAAM,EAAG,EACxC,CAAC;EACJ;EAEA,IAAAwC,iBAAA,GAA6C7E,gBAAgB,CAAC,YAAM;MAClE,IAAM8E,YAAY,GAAGrE,WAAW,CAACuB,KAAK,CAACN,QAAQ,EAAEO,IAAI,CAAC4B,KAAK,CAACxB,KAAK,CAAC;MAClE,IAAM0C,YAAY,GAChB/C,KAAK,CAACL,MAAM,KAAK,SAAS,GAAGmD,YAAY,GACvC9C,KAAK,CAACL,MAAM,KAAK,MAAM,GAAGxB,QAAQ,CAAC2E,YAAY,CAAC,GAChDrE,WAAW,CAACuB,KAAK,CAACL,MAAM,EAAEM,IAAI,CAAC4B,KAAK,CAACxB,KAAK,CAAC;;MAE/C;MACA,IAAIyC,YAAY,CAACE,IAAI,KAAKD,YAAY,CAACC,IAAI,IAAIF,YAAY,CAACG,KAAK,KAAKhF,SAAS,CAAC8E,YAAY,CAAC,CAACE,KAAK,EAAE;QACnG,OAAO;UACLC,eAAe,EAAEhF,UAAU,CAAC4E,YAAY,CAAC;UACzCK,eAAe,EAAEjF,UAAU,CAAC6E,YAAY;QAC1C,CAAC;MACH,CAAC,MAAM;QACL,OAAO;UACLG,eAAe,EAAEJ,YAAY;UAC7BK,eAAe,EAAEJ;QACnB,CAAC;MACH;IACF,CAAC,CAAC;IAnBMG,eAAe,GAAAL,iBAAA,CAAfK,eAAe;IAAEC,eAAA,GAAAN,iBAAA,CAAAM,eAAA;EAqBzB,IAAAC,IAAA,GACG,CAAC,UAAU,EAAE,WAAW,EAAE,UAAU,EAAE,WAAW,CAAC,CAAWC,GAAG,CAAC,UAAAC,GAAG,EAAI;MACvE,OAAOlG,QAAQ,CAAC,YAAM;QACpB,IAAMqC,GAAG,GAAGuC,UAAU,CAAChC,KAAK,CAACsD,GAAG,CAAE,CAAC;QACnC,OAAOC,KAAK,CAAC9D,GAAG,CAAC,GAAG+D,QAAQ,GAAG/D,GAAG;MACpC,CAAC,CAAC;IACJ,CAAC,CAAC;IAAAgE,KAAA,GAAAC,cAAA,CAAAN,IAAA;IANGO,QAAQ,GAAAF,KAAA;IAAEG,SAAS,GAAAH,KAAA;IAAEI,QAAQ,GAAAJ,KAAA;IAAEK,SAAS,GAAAL,KAAA;EAQ/C,IAAM7D,MAAM,GAAGxC,QAAQ,CAAC,YAAM;IAC5B,IAAI0C,KAAK,CAACyC,OAAO,CAACvC,KAAK,CAACJ,MAAM,CAAC,EAAE;MAC/B,OAAOI,KAAK,CAACJ,MAAM;IACrB;IACA,IAAI,OAAOI,KAAK,CAACJ,MAAM,KAAK,QAAQ,EAAE;MACpC,IAAMA,OAAM,GAAGI,KAAK,CAACJ,MAAM,CAACmE,KAAK,CAAC,GAAG,CAAC,CAACV,GAAG,CAACrB,UAAU,CAAC;MACtD,IAAIpC,OAAM,CAACoE,MAAM,GAAG,CAAC,EAAEpE,OAAM,CAACqE,IAAI,CAAC,CAAC,CAAC;MACrC,OAAOrE,OAAM;IACf;IACA,OAAO,OAAOI,KAAK,CAACJ,MAAM,KAAK,QAAQ,GAAG,CAACI,KAAK,CAACJ,MAAM,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;EACtE,CAAC,CAAC;EAEF,IAAIsE,OAAO,GAAG,KAAK;EACnB,IAAIC,SAAS,GAAG,CAAC,CAAC;EAClB,IAAMC,OAAO,GAAG,IAAIzG,cAAc,CAA6B,CAAC,CAAC;EACjE,IAAM0G,QAAQ,GAAG,IAAIC,cAAc,CAAC,YAAM;IACxC,IAAI,CAACJ,OAAO,EAAE;;IAEd;IACAK,qBAAqB,CAAC,UAAAC,OAAO,EAAI;MAC/B,IAAIA,OAAO,KAAKL,SAAS,EAAEC,OAAO,CAACK,KAAK,CAAC,CAAC;MAC1CF,qBAAqB,CAAC,UAAAG,UAAU,EAAI;QAClCP,SAAS,GAAGO,UAAU;MACxB,CAAC,CAAC;IACJ,CAAC,CAAC;IAEF,IAAIN,OAAO,CAACO,MAAM,EAAE;MAClB,IAAMC,MAAM,GAAGR,OAAO,CAACQ,MAAM,CAAC,CAAC;MAC/B,IACE7G,SAAS,CAAC6G,MAAM,CAACC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAED,MAAM,CAACC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,IACvC,CAAC9G,SAAS,CAAC6G,MAAM,CAACC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAED,MAAM,CAACC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EACxC;QACA;QACA;MACF;IACF;IAEA,IAAMC,MAAM,GAAG3E,cAAc,CAAC,CAAC;IAC/B,IAAI2E,MAAM,EAAEV,OAAO,CAACH,IAAI,CAACa,MAAM,CAACV,OAAO,CAAC;EAC1C,CAAC,CAAC;EAEF5G,KAAK,CAAC,CAACyC,IAAI,CAACuC,MAAM,EAAEvC,IAAI,CAAC8E,SAAS,CAAC,EAAE,UAAAC,IAAA,EAAAC,KAAA,EAA0D;IAAA,IAAAC,KAAA,GAAAxB,cAAA,CAAhCsB,IAAA;MAAxBG,SAAS,GAAAD,KAAA;MAAEE,YAAY,GAAAF,KAAA;IAAC,IAAAG,KAAA,GAAA3B,cAAA,CAA2BuB,KAAA;MAAxBK,SAAS,GAAAD,KAAA;MAAEE,YAAY,GAAAF,KAAA;IACvF,IAAIC,SAAS,IAAI,CAACxF,KAAK,CAACyC,OAAO,CAAC+C,SAAS,CAAC,EAAEjB,QAAQ,CAACmB,SAAS,CAACF,SAAS,CAAC;IACzE,IAAIH,SAAS,IAAI,CAACrF,KAAK,CAACyC,OAAO,CAAC4C,SAAS,CAAC,EAAEd,QAAQ,CAACH,OAAO,CAACiB,SAAS,CAAC;IAEvE,IAAII,YAAY,EAAElB,QAAQ,CAACmB,SAAS,CAACD,YAAY,CAAC;IAClD,IAAIH,YAAY,EAAEf,QAAQ,CAACH,OAAO,CAACkB,YAAY,CAAC;EAClD,CAAC,EAAE;IACDK,SAAS,EAAE;EACb,CAAC,CAAC;EAEFnI,cAAc,CAAC,YAAM;IACnB+G,QAAQ,CAACqB,UAAU,CAAC,CAAC;EACvB,CAAC,CAAC;EAEF,IAAIC,SAAS,GAAG,IAAIhH,GAAG,CAAC;IAAEoD,CAAC,EAAE,CAAC;IAAEK,CAAC,EAAE,CAAC;IAAEwD,KAAK,EAAE,CAAC;IAAEC,MAAM,EAAE;EAAE,CAAC,CAAC;;EAE5D;EACA,SAAS1F,cAAcA,CAAA,EAAI;IACzB+D,OAAO,GAAG,KAAK;IACfK,qBAAqB,CAAC;MAAA,OAAML,OAAO,GAAG,IAAI;IAAA,EAAC;IAE3C,IAAI,CAACjE,IAAI,CAACuC,MAAM,CAACnC,KAAK,IAAI,CAACJ,IAAI,CAAC8E,SAAS,CAAC1E,KAAK,EAAE;IAEjD,IACEP,KAAK,CAACyC,OAAO,CAACtC,IAAI,CAACuC,MAAM,CAACnC,KAAK,CAAC,IAChCJ,IAAI,CAACuC,MAAM,CAACnC,KAAK,CAACyF,YAAY,IAC9B7F,IAAI,CAACuC,MAAM,CAACnC,KAAK,CAAC0F,cAAc,CAAC,CAAC,CAAC/B,MAAM,EACzC;MACA2B,SAAS,GAAG7G,YAAY,CAACmB,IAAI,CAACuC,MAAM,CAACnC,KAAK,CAAC;IAC7C,CAAC,CAAC;;IAEF,IAAMyB,UAAU,GAAGH,gBAAgB,CAAC1B,IAAI,CAAC8E,SAAS,CAAC1E,KAAK,EAAEJ,IAAI,CAAC4B,KAAK,CAACxB,KAAK,CAAC;IAC3E,IAAM2F,aAAa,GAAG3H,gBAAgB,CAAC4B,IAAI,CAAC8E,SAAS,CAAC1E,KAAK,CAAC;IAC5D,IAAM4F,cAAc,GAAG,EAAE;IAEzB,IAAI,CAACD,aAAa,CAAChC,MAAM,EAAE;MACzBgC,aAAa,CAAC/B,IAAI,CAACiC,QAAQ,CAACC,eAAe,CAAC;MAC5C,IAAI,EAAElG,IAAI,CAAC8E,SAAS,CAAC1E,KAAK,CAAC4B,KAAK,CAACI,GAAG,IAAIpC,IAAI,CAAC8E,SAAS,CAAC1E,KAAK,CAAC4B,KAAK,CAACE,IAAI,CAAC,EAAE;QACxEL,UAAU,CAACC,CAAC,IAAIC,UAAU,CAACkE,QAAQ,CAACC,eAAe,CAAClE,KAAK,CAACmE,gBAAgB,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;QACrGtE,UAAU,CAACM,CAAC,IAAIJ,UAAU,CAACkE,QAAQ,CAACC,eAAe,CAAClE,KAAK,CAACmE,gBAAgB,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;MACvG;IACF;IAEA,IAAMC,QAAQ,GAAGL,aAAa,CAACM,MAAM,CAAM,UAACC,GAAoB,EAAE3E,EAAE,EAAK;MACvE,IAAM4E,SAAS,GAAG5H,aAAa,CAACgD,EAAE,CAAC;MAEnC,IAAI2E,GAAG,EAAE;QACP,OAAO,IAAI5H,GAAG,CAAC;UACboD,CAAC,EAAE0E,IAAI,CAACC,GAAG,CAACH,GAAG,CAACpE,IAAI,EAAEqE,SAAS,CAACrE,IAAI,CAAC;UACrCC,CAAC,EAAEqE,IAAI,CAACC,GAAG,CAACH,GAAG,CAAClE,GAAG,EAAEmE,SAAS,CAACnE,GAAG,CAAC;UACnCuD,KAAK,EAAEa,IAAI,CAACE,GAAG,CAACJ,GAAG,CAACrE,KAAK,EAAEsE,SAAS,CAACtE,KAAK,CAAC,GAAGuE,IAAI,CAACC,GAAG,CAACH,GAAG,CAACpE,IAAI,EAAEqE,SAAS,CAACrE,IAAI,CAAC;UAChF0D,MAAM,EAAEY,IAAI,CAACE,GAAG,CAACJ,GAAG,CAACK,MAAM,EAAEJ,SAAS,CAACI,MAAM,CAAC,GAAGH,IAAI,CAACC,GAAG,CAACH,GAAG,CAAClE,GAAG,EAAEmE,SAAS,CAACnE,GAAG;QAClF,CAAC,CAAC;MACJ;MACA,OAAOmE,SAAS;IAClB,CAAC,EAAEvF,SAAU,CAAC;IACdoF,QAAQ,CAACtE,CAAC,IAAIkE,cAAc;IAC5BI,QAAQ,CAACjE,CAAC,IAAI6D,cAAc;IAC5BI,QAAQ,CAACT,KAAK,IAAIK,cAAc,GAAG,CAAC;IACpCI,QAAQ,CAACR,MAAM,IAAII,cAAc,GAAG,CAAC;IAErC,IAAIY,SAAS,GAAG;MACdC,MAAM,EAAE5D,eAAe,CAAC7C,KAAK;MAC7BV,MAAM,EAAEwD,eAAe,CAAC9C;IAC1B,CAAC;IAED,SAAS0G,aAAaA,CAAEC,UAA4B,EAAE;MACpD,IAAMT,GAAG,GAAG,IAAI5H,GAAG,CAACmD,UAAU,CAAC;MAC/B,IAAMmF,WAAW,GAAGxJ,aAAa,CAACuJ,UAAU,CAACF,MAAM,EAAEnB,SAAS,CAAC;MAC/D,IAAMuB,YAAY,GAAGzJ,aAAa,CAACuJ,UAAU,CAACrH,MAAM,EAAE4G,GAAG,CAAC;MAE1D,IAAAY,UAAA,GAAezJ,SAAS,CAACuJ,WAAW,EAAEC,YAAY,CAAC;QAA7CnF,CAAC,GAAAoF,UAAA,CAADpF,CAAC;QAAEK,CAAA,GAAA+E,UAAA,CAAA/E,CAAA;MAET,QAAQ4E,UAAU,CAACF,MAAM,CAAC9D,IAAI;QAC5B,KAAK,KAAK;UAAEZ,CAAC,IAAIxC,MAAM,CAACS,KAAK,CAAC,CAAC,CAAC;UAAE;QAClC,KAAK,QAAQ;UAAE+B,CAAC,IAAIxC,MAAM,CAACS,KAAK,CAAC,CAAC,CAAC;UAAE;QACrC,KAAK,MAAM;UAAE0B,CAAC,IAAInC,MAAM,CAACS,KAAK,CAAC,CAAC,CAAC;UAAE;QACnC,KAAK,OAAO;UAAE0B,CAAC,IAAInC,MAAM,CAACS,KAAK,CAAC,CAAC,CAAC;UAAE;MACtC;MAEA,QAAQ2G,UAAU,CAACF,MAAM,CAAC7D,KAAK;QAC7B,KAAK,KAAK;UAAEb,CAAC,IAAIxC,MAAM,CAACS,KAAK,CAAC,CAAC,CAAC;UAAE;QAClC,KAAK,QAAQ;UAAE+B,CAAC,IAAIxC,MAAM,CAACS,KAAK,CAAC,CAAC,CAAC;UAAE;QACrC,KAAK,MAAM;UAAE0B,CAAC,IAAInC,MAAM,CAACS,KAAK,CAAC,CAAC,CAAC;UAAE;QACnC,KAAK,OAAO;UAAE0B,CAAC,IAAInC,MAAM,CAACS,KAAK,CAAC,CAAC,CAAC;UAAE;MACtC;MAEAkG,GAAG,CAACxE,CAAC,IAAIA,CAAC;MACVwE,GAAG,CAACnE,CAAC,IAAIA,CAAC;MAEVmE,GAAG,CAACX,KAAK,GAAGa,IAAI,CAACE,GAAG,CAACJ,GAAG,CAACX,KAAK,EAAE/B,QAAQ,CAACxD,KAAK,CAAC;MAC/CkG,GAAG,CAACV,MAAM,GAAGY,IAAI,CAACE,GAAG,CAACJ,GAAG,CAACV,MAAM,EAAE/B,SAAS,CAACzD,KAAK,CAAC;MAElD,IAAM+G,SAAS,GAAGvI,WAAW,CAAC0H,GAAG,EAAEF,QAAQ,CAAC;MAE5C,OAAO;QAAEe,SAAS,EAATA,SAAS;QAAErF,CAAC,EAADA,CAAC;QAAEK,CAAA,EAAAA;MAAE,CAAC;IAC5B;IAEA,IAAIL,CAAC,GAAG,CAAC;IAAE,IAAIK,CAAC,GAAG,CAAC;IACpB,IAAMiF,SAAS,GAAG;MAAEtF,CAAC,EAAE,CAAC;MAAEK,CAAC,EAAE;IAAE,CAAC;IAChC,IAAMgC,OAAO,GAAG;MAAErC,CAAC,EAAE,KAAK;MAAEK,CAAC,EAAE;IAAM,CAAC;IACtC,IAAIkF,MAAM,GAAG,CAAC,CAAC;IAAA,IAAAC,KAAA,YAAAA,MAAA,EACF;QACX,IAAID,MAAM,EAAE,GAAG,EAAE,EAAE;UACjBzJ,YAAY,CAAC,qDAAqD,CAAC;UAAA;QAErE;QAEA,IAAA2J,cAAA,GAAoCT,aAAa,CAACF,SAAS,CAAC;UAAjDY,EAAE,GAAAD,cAAA,CAALzF,CAAC;UAAS2F,EAAE,GAAAF,cAAA,CAALpF,CAAC;UAAMgF,SAAA,GAAAI,cAAA,CAAAJ,SAAA;QAEtBrF,CAAC,IAAI0F,EAAE;QACPrF,CAAC,IAAIsF,EAAE;QAEP5F,UAAU,CAACC,CAAC,IAAI0F,EAAE;QAClB3F,UAAU,CAACM,CAAC,IAAIsF,EAAE;;QAElB;QACA;UACE,IAAMC,KAAI,GAAGvJ,OAAO,CAACyI,SAAS,CAACC,MAAM,CAAC;UACtC,IAAMc,YAAY,GAAGR,SAAS,CAACrF,CAAC,CAAC8F,MAAM,IAAIT,SAAS,CAACrF,CAAC,CAAC+F,KAAK;UAC5D,IAAMC,YAAY,GAAGX,SAAS,CAAChF,CAAC,CAACyF,MAAM,IAAIT,SAAS,CAAChF,CAAC,CAAC0F,KAAK;UAE5D,IAAIxH,KAAK,GAAG,KAAK;UAChB,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC0H,OAAO,CAAC,UAAA1E,GAAG,EAAI;YACzB,IACGA,GAAG,KAAK,GAAG,IAAIsE,YAAY,IAAI,CAACxD,OAAO,CAACrC,CAAC,IACzCuB,GAAG,KAAK,GAAG,IAAIyE,YAAY,IAAI,CAAC3D,OAAO,CAAChC,CAAE,EAC3C;cACA,IAAM6F,YAAY,GAAG;gBAAEnB,MAAM,EAAAoB,aAAA,KAAOrB,SAAS,CAACC,MAAA,CAAQ;gBAAEnH,MAAM,EAAAuI,aAAA,KAAOrB,SAAS,CAAClH,MAAA;cAAS,CAAC;cACzF,IAAMwI,IAAI,GAAG7E,GAAG,KAAK,GAAG,GACpBqE,KAAI,KAAK,GAAG,GAAG1J,SAAS,GAAGE,QAAQ,GACnCwJ,KAAI,KAAK,GAAG,GAAGxJ,QAAQ,GAAGF,SAAS;cACvCgK,YAAY,CAACnB,MAAM,GAAGqB,IAAI,CAACF,YAAY,CAACnB,MAAM,CAAC;cAC/CmB,YAAY,CAACtI,MAAM,GAAGwI,IAAI,CAACF,YAAY,CAACtI,MAAM,CAAC;cAC/C,IAAAyI,eAAA,GAAoCrB,aAAa,CAACkB,YAAY,CAAC;gBAA5CI,YAAA,GAAAD,eAAA,CAAXhB,SAAS;cACjB,IACGiB,YAAY,CAAC/E,GAAG,CAAC,CAACuE,MAAM,IAAIT,SAAS,CAAC9D,GAAG,CAAC,CAACuE,MAAM,IAChDQ,YAAY,CAAC/E,GAAG,CAAC,CAACwE,KAAK,IAAIV,SAAS,CAAC9D,GAAG,CAAC,CAACwE,KAAK,IAChDO,YAAY,CAAC/E,GAAG,CAAC,CAACuE,MAAM,GAAGQ,YAAY,CAAC/E,GAAG,CAAC,CAACwE,KAAK,GACjD,CAACV,SAAS,CAAC9D,GAAG,CAAC,CAACuE,MAAM,GAAGT,SAAS,CAAC9D,GAAG,CAAC,CAACwE,KAAK,IAAI,CAAE,EACrD;gBACAjB,SAAS,GAAGoB,YAAY;gBACxB3H,KAAK,GAAG8D,OAAO,CAACd,GAAG,CAAC,GAAG,IAAI;cAC7B;YACF;UACF,CAAC,CAAC;UACF,IAAIhD,KAAK;QACX;;QAEA;QACA,IAAI8G,SAAS,CAACrF,CAAC,CAAC8F,MAAM,EAAE;UACtB9F,CAAC,IAAIqF,SAAS,CAACrF,CAAC,CAAC8F,MAAM;UACvB/F,UAAU,CAACC,CAAC,IAAIqF,SAAS,CAACrF,CAAC,CAAC8F,MAAM;QACpC;QACA,IAAIT,SAAS,CAACrF,CAAC,CAAC+F,KAAK,EAAE;UACrB/F,CAAC,IAAIqF,SAAS,CAACrF,CAAC,CAAC+F,KAAK;UACtBhG,UAAU,CAACC,CAAC,IAAIqF,SAAS,CAACrF,CAAC,CAAC+F,KAAK;QACnC;QACA,IAAIV,SAAS,CAAChF,CAAC,CAACyF,MAAM,EAAE;UACtBzF,CAAC,IAAIgF,SAAS,CAAChF,CAAC,CAACyF,MAAM;UACvB/F,UAAU,CAACM,CAAC,IAAIgF,SAAS,CAAChF,CAAC,CAACyF,MAAM;QACpC;QACA,IAAIT,SAAS,CAAChF,CAAC,CAAC0F,KAAK,EAAE;UACrB1F,CAAC,IAAIgF,SAAS,CAAChF,CAAC,CAAC0F,KAAK;UACtBhG,UAAU,CAACM,CAAC,IAAIgF,SAAS,CAAChF,CAAC,CAAC0F,KAAK;QACnC;;QAEA;QACA;UACE,IAAMV,UAAS,GAAGvI,WAAW,CAACiD,UAAU,EAAEuE,QAAQ,CAAC;UACnDgB,SAAS,CAACtF,CAAC,GAAGsE,QAAQ,CAACT,KAAK,GAAGwB,UAAS,CAACrF,CAAC,CAAC8F,MAAM,GAAGT,UAAS,CAACrF,CAAC,CAAC+F,KAAK;UACrET,SAAS,CAACjF,CAAC,GAAGiE,QAAQ,CAACR,MAAM,GAAGuB,UAAS,CAAChF,CAAC,CAACyF,MAAM,GAAGT,UAAS,CAAChF,CAAC,CAAC0F,KAAK;UAEtE/F,CAAC,IAAIqF,UAAS,CAACrF,CAAC,CAAC8F,MAAM;UACvB/F,UAAU,CAACC,CAAC,IAAIqF,UAAS,CAACrF,CAAC,CAAC8F,MAAM;UAClCzF,CAAC,IAAIgF,UAAS,CAAChF,CAAC,CAACyF,MAAM;UACvB/F,UAAU,CAACM,CAAC,IAAIgF,UAAS,CAAChF,CAAC,CAACyF,MAAM;QACpC;QAAA;MAGF;MAAAS,IAAA;IA9EA,OAAO,IAAI;MAAAA,IAAA,GAAAf,KAAA;MAAA,IAAAe,IAAA,QAGP;MAAA,IAAAA,IAAA,QAyCW;IAAA;IAoCf,IAAMX,IAAI,GAAGvJ,OAAO,CAACyI,SAAS,CAACC,MAAM,CAAC;IAEtCrE,MAAM,CAACC,MAAM,CAACxC,aAAa,CAACG,KAAK,EAAE;MACjC,2BAA2B,KAAAkI,MAAA,CAAK1B,SAAS,CAACC,MAAM,CAAC9D,IAAI,OAAAuF,MAAA,CAAI1B,SAAS,CAACC,MAAM,CAAC7D,KAAK,CAAE;MACjFuF,eAAe,KAAAD,MAAA,CAAK1B,SAAS,CAAClH,MAAM,CAACqD,IAAI,OAAAuF,MAAA,CAAI1B,SAAS,CAAClH,MAAM,CAACsD,KAAK,CAAE;MACrE;MACAZ,GAAG,EAAEvE,aAAa,CAAC2K,UAAU,CAACrG,CAAC,CAAC,CAAC;MACjCD,IAAI,EAAElC,IAAI,CAAC4B,KAAK,CAACxB,KAAK,GAAGY,SAAS,GAAGnD,aAAa,CAAC2K,UAAU,CAAC1G,CAAC,CAAC,CAAC;MACjEG,KAAK,EAAEjC,IAAI,CAAC4B,KAAK,CAACxB,KAAK,GAAGvC,aAAa,CAAC2K,UAAU,CAAC,CAAC1G,CAAC,CAAC,CAAC,GAAGd,SAAS;MACnE0C,QAAQ,EAAE7F,aAAa,CAAC6J,IAAI,KAAK,GAAG,GAAGlB,IAAI,CAACE,GAAG,CAAChD,QAAQ,CAACtD,KAAK,EAAEsF,SAAS,CAACC,KAAK,CAAC,GAAGjC,QAAQ,CAACtD,KAAK,CAAC;MAClGwD,QAAQ,EAAE/F,aAAa,CAAC4K,SAAS,CAAC9K,KAAK,CAACyJ,SAAS,CAACtF,CAAC,EAAE4B,QAAQ,CAACtD,KAAK,KAAKmD,QAAQ,GAAG,CAAC,GAAGG,QAAQ,CAACtD,KAAK,EAAEwD,QAAQ,CAACxD,KAAK,CAAC,CAAC,CAAC;MACxHyD,SAAS,EAAEhG,aAAa,CAAC4K,SAAS,CAAC9K,KAAK,CAACyJ,SAAS,CAACjF,CAAC,EAAEwB,SAAS,CAACvD,KAAK,KAAKmD,QAAQ,GAAG,CAAC,GAAGI,SAAS,CAACvD,KAAK,EAAEyD,SAAS,CAACzD,KAAK,CAAC,CAAC;IAC7H,CAAC,CAAC;IAEF,OAAO;MACLgH,SAAS,EAATA,SAAS;MACTvF,UAAU,EAAVA,UAAU;MACVsC,OAAA,EAAAA;IACF,CAAC;EACH;EAEA5G,KAAK,CACH;IAAA,OAAM,CACJ0F,eAAe,CAAC7C,KAAK,EACrB8C,eAAe,CAAC9C,KAAK,EACrBL,KAAK,CAACJ,MAAM,EACZI,KAAK,CAAC2D,QAAQ,EACd3D,KAAK,CAAC4D,SAAS,EACf5D,KAAK,CAAC6D,QAAQ,EACd7D,KAAK,CAAC8D,SAAS,CAChB;EAAA,GACD;IAAA,OAAM3D,cAAc,CAAC,CACvB;EAAA,EAAC;EAED9C,QAAQ,CAAC,YAAM;IACb,IAAMyH,MAAM,GAAG3E,cAAc,CAAC,CAAC;;IAE/B;IACA;IACA,IAAI,CAAC2E,MAAM,EAAE;IACb,IAAQuC,SAAS,GAAiBvC,MAAM,CAAhCuC,SAAS;MAAEvF,UAAA,GAAegD,MAAM,CAArBhD,UAAA;IACnB,IAAIA,UAAU,CAAC+D,MAAM,GAAGwB,SAAS,CAACjF,CAAC,EAAE;MACnCmC,qBAAqB,CAAC,YAAM;QAC1BpE,cAAc,CAAC,CAAC;QAChBoE,qBAAqB,CAAC,YAAM;UAC1BpE,cAAc,CAAC,CAAC;QAClB,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ;EACF,CAAC,CAAC;EAEF,OAAO;IAAEA,cAAA,EAAAA;EAAe,CAAC;AAC3B;AAEA,SAASsI,UAAUA,CAAEhJ,GAAW,EAAE;EAChC,OAAOgH,IAAI,CAACkC,KAAK,CAAClJ,GAAG,GAAGmJ,gBAAgB,CAAC,GAAGA,gBAAgB;AAC9D;AAEA,SAASF,SAASA,CAAEjJ,GAAW,EAAE;EAC/B,OAAOgH,IAAI,CAACoC,IAAI,CAACpJ,GAAG,GAAGmJ,gBAAgB,CAAC,GAAGA,gBAAgB;AAC7D","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}